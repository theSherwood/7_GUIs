{"version":3,"sources":["node_modules/sinuous-style/src/utils.js","node_modules/sinuous-style/src/scopeStyles.js","../observable/src/observable.js","../observable/src/utils.js","../htm/src/index.js","../htm/src/build.js","../h/src/index.js","../h/src/api.js","../h/src/constants.js","../h/src/add.js","../h/src/frag.js","../h/src/cast-node.js","../h/src/remove-nodes.js","../h/src/property.js","../h/src/h.js","../src/index.js","../h/src/insert.js","node_modules/sinuous-style/src/index.js","src/components/card.js","src/tasks/counter.js","src/tasks/temperatureConverter.js","src/tasks/flightBooker.js","src/tasks/timer.js","src/tasks/crud.js","src/tasks/circleDrawer.js","src/tasks/cells/sampleData.js","src/tasks/cells/parse.js","src/tasks/cells/cells.js","src/app.js","src/index.js"],"names":["isFunction","item","RULE_BLOCK","COMMA","AT_RULE","WHITESPACE","LIMITER","FUNCTION","SELECTOR","END","tokenize","styles","flatMap","section","split","tokens","type","char","charsLength","bracketStack","chars","pushToken","push","token","join","undefined","i","length","includes","insertScopeName","selector","scopeName","first","slice","scopeSelectors","styleTokens","reduce","acc","current","sections","scopeStyles","EMPTY_ARR","tracking","queue","isListening","root","fn","prevTracking","rootUpdate","resetUpdate","result","_unsubscribe","sample","value","transaction","prevQueue","q","forEach","data","_pending","pending","observable","nextValue","arguments","_observers","has","add","_observables","clearedUpdate","_runObservers","Set","observer","_fresh","$o","computed","update","_children","prevChildren","u","indexOf","getChildrenDeep","children","res","curr","concat","removeFreshChildren","o","_update","delete","cleanup","_cleanups","subscribe","on","obs","seed","onchanges","unsubscribe","c","evaluate","h","built","fields","args","propBody","field","Object","assign","key","prev","parts","prop","j","call","this","apply","build","statics","propName","mode","buffer","quote","commit","replace","CACHES","Map","regular","tmp","get","set","custom","Array","isArray","bind","wrap","api","parent","endMark","fragOrNode","childNodes","nodeType","t","document","createTextNode","Node","insertBefore","parentNode","removeNodes","startNode","n","nextSibling","removeChild","eventProxy","e","_listeners","context","options","isSvg","from","el","arg","createElementNS","createElement","createDocumentFragment","property","insert","splice","hs","html","htm","svg","_startMark","previousSibling","textContent","firstChild","lastChild","name","isAttr","isCss","style","setProperty","setAttribute","cssText","toLowerCase","addEventListener","removeEventListener","rm","scopeNameCounts","styleElementIds","pipe","f","g","originalH","scopeElementClasses","injectScopeName","head","querySelector","addStyleElement","styleElement","append","removeStyleByClassName","className","element","querySelectorAll","nodeName","id","remove","local","global","props","class","modifiedScopeName","rest","wrapInScope","newScopeName","callback","outerScopeName","staticScopeName","$s","temp","baseClass","wrapApiFunction","templateArgs","sinuousHtml","sinuousSvg","card","title","counter","count","trunc","Number","toFixed","remove0","test","getC","getF","r","isValid","temperatureConverter","to","target","flightMap","tryAsDate","dateString","dateArr","reverse","Date","valueOf","formatAsString","date","toISOString","flightBooker","flightType","startDate","returnDate","error1","error2","error3","isBookButtonDisabled","isOneWay","startDateClass","returnDateClass","book","timeStrings","alert","timer","MAX","interval","duration","durationFormatted","start","time","progress","startTimer","clearInterval","setInterval","crud","prefix","entries","filteredEntries","map","entry","filter","startsWith","surname","selected","createHandler","updateHandler","deleteHandler","circleDrawer","BASE_RADIUS","step","snapshots","radius","resizing","present","handleRightClick","preventDefault","stopPropagation","circle","x","cx","baseVal","y","cy","addCircle","layerX","layerY","newSnapshot","addSnapshot","newSnapshots","endResize","resizingIndex","findIndex","newPresent","overlay","circleSVG","view","undo","Math","max","redo","min","cir","sampleData","A0","A1","A2","A3","B1","B2","A5","B5","A6","B6","A7","B7","A8","B8","A9","B9","A10","B10","C0","D0","C1","D1","C2","D2","C3","D3","C4","D4","C5","D5","C7","D7","C8","D8","C9","D9","C10","D10","C11","D11","C12","D12","C14","D14","C15","D15","Parser","store","columns","rows","cells","operations","sum","a","b","sub","mul","div","mod","exp","letters","numbers","letter","number","arr","end","startI","endI","rangeStart","rangeEnd","splitOperand","findArrRange","cartesianProduct","operand","match","op","isWellFormed","getRange","address","parse","originalString","operand1","operand2","parseOperand","second","toString","isNaN","formula","endsWith","operationType","formulaArr","singleOperation","rangeOperation","str","parseOperation","toUpperCase","LETTERS","range","keys","letterRange","getNumberAsLetters","getBase26","remainder","floor","num","findAdjacent","direction","index","shape","tBody","p","focused","handleFocus","createNewCell","dataRef","focus","setSelectionRange","cellView","hasFocus","handleBlur","handleKeydown","column","row","newRow","altKey","newColumn","handleInput","clear","app"],"mappings":"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","file":"src.eec90cab.js","sourceRoot":"..","sourcesContent":["export const isFunction = (item) => typeof item === \"function\";\n","import { isFunction } from \"./utils\";\n\n// Token types\nconst RULE_BLOCK = 1;\nconst COMMA = 2;\nconst AT_RULE = 3;\nconst WHITESPACE = 4;\nconst LIMITER = 5;\nconst FUNCTION = 6;\nconst SELECTOR = 7;\nconst END = 8;\n\n/**\n * Tokenizes an array of style strings from a <style /> element.\n * Style elements can contain observables (or other values),\n * making the array of the following form:\n *\n * ['div { background: ', observableFn, '; }']\n *\n * Note: only obserables within a rule-block are expected.\n * Observables or other values in the place of selectors\n * or other css entities will lead to unexpected behavior.\n *\n * @param {Array} styles - An array of strings potentially interspersed with observables and other values\n * @return {Array} An array of tokens: RULE_BLOCK | COMMA | AT_RULE | WHITESPACE | LIMITER | FUNCTION | SELECTOR\n */\nfunction tokenize(styles) {\n  styles = styles.flatMap((section) =>\n    typeof section === \"string\" ? section.split(\"\") : section\n  );\n\n  let tokens = [];\n  let bracketStack = 0;\n  let chars = [];\n  let type;\n\n  function pushToken() {\n    tokens.push({\n      token: chars.join(\"\"),\n      type,\n    });\n    type = undefined;\n    chars = [];\n  }\n\n  let char;\n  let charsLength;\n  for (let i = 0; i < styles.length; i++) {\n    char = styles[i];\n    charsLength = chars.length;\n    if (isFunction(char)) {\n      if (charsLength) {\n        pushToken();\n      }\n      tokens.push({ token: char, type: FUNCTION });\n    } else if (bracketStack) {\n      if (!charsLength) {\n        type = RULE_BLOCK;\n      }\n      chars.push(char);\n      if (char === \"{\") {\n        bracketStack++;\n      } else if (char === \"}\") {\n        bracketStack--;\n        if (!bracketStack) {\n          pushToken();\n        }\n      }\n    } else {\n      if (char === \"{\") {\n        if (charsLength) {\n          pushToken();\n        }\n        bracketStack++;\n        type = RULE_BLOCK;\n        chars.push(char);\n      } else if (char === \",\") {\n        if (charsLength && type !== AT_RULE) {\n          pushToken();\n        }\n        type = COMMA;\n        chars.push(char);\n        pushToken();\n      } else if (\">+~\".includes(char) && type !== SELECTOR) {\n        if (charsLength && type !== AT_RULE) {\n          pushToken();\n          tokens.push({ token: char, type: LIMITER });\n        } else {\n          chars.push(char);\n        }\n      } else if (\" \\n\\t\\r\".includes(char)) {\n        if (charsLength && ![WHITESPACE, AT_RULE].includes(type)) {\n          pushToken();\n        }\n        type = WHITESPACE;\n        chars.push(char);\n      } else if (char === \"@\") {\n        if (charsLength) {\n          pushToken();\n        }\n        type = AT_RULE;\n        chars.push(char);\n      } else {\n        if (!charsLength) {\n          type = SELECTOR;\n          chars.push(char);\n        } else if ([SELECTOR, AT_RULE].includes(type)) {\n          chars.push(char);\n        } else {\n          pushToken();\n          type = SELECTOR;\n          chars.push(char);\n        }\n      }\n    }\n  }\n\n  if (chars.length) {\n    pushToken();\n  }\n\n  return tokens;\n}\n\n/**\n * Adds the `scopeName` after tags but before ids, other classNames,\n * pseudoSelectors, and attribute selectors. For example:\n *\n * `div.some-class` becomes `div.<scopeName>.some-class`\n *\n * @param {String} selector - A css selector\n * @param {String} scopeName - The className used to scope the `selector`\n * @return {String}\n */\nfunction insertScopeName(selector, scopeName) {\n  let i = 0;\n  while (!\"#.:[\".includes(selector[i]) && i !== selector.length) {\n    i++;\n  }\n  let first = selector.slice(0, i);\n  let second = selector.slice(i);\n  return first + \".\" + scopeName + second;\n}\n\n/**\n * @param {Array} styleTokens - The result of `tokenize(styles)`\n * @param {String} scopeName - The className used to scope the `Selector` tokens\n * @return {Array} An array of the form of `styles` passed to `tokenize`,\n * but with all the selectors scoped to `scopeName`\n */\nfunction scopeSelectors(styleTokens, scopeName) {\n  styleTokens.push({ type: END });\n  let styles = styleTokens.reduce(\n    (acc, token) => {\n      let current = acc[0];\n      let sections = acc[1];\n      if (token.type === SELECTOR) {\n        current.push(insertScopeName(token.token, scopeName));\n      } else if (token.type === FUNCTION) {\n        sections.push(current.join(\"\"));\n        sections.push(token.token);\n        current = [];\n      } else if (token.type === END) {\n        sections.push(current.join(\"\"));\n        return sections;\n      } else {\n        current.push(token.token);\n      }\n      return [current, sections];\n    },\n    [\n      [], // current section\n      [], // sections thus far\n    ]\n  );\n  return styles;\n}\n\n/**\n * Scopes `styles` from a <style /> element.\n * Style elements can contain observables (or other values),\n * making the `styles` array of the following form:\n *\n * ['div.classes { background: ', observableFn, '; }']\n *\n * It returns an array of the following form:\n *\n * ['div.scopeName.classes { background: ', observableFn, '; }']\n *\n * Note: only obserables within a rule-block are expected.\n * Observables or other values in the place of selectors\n * or other css entities will lead to unexpected behavior.\n *\n * @param {Array} styles - An array of style strings and inclusions (observables and other values)\n * @param {Array} scopeName - A string representing a className to inject into the styles\n * @return {Array} A `styles` array but with css selectors now scoped to the `scopeName`\n */\nexport function scopeStyles(styles, scopeName) {\n  return scopeSelectors(tokenize(styles), scopeName);\n}\n","import { getChildrenDeep } from './utils.js';\n\nconst EMPTY_ARR = [];\nlet tracking;\nlet queue;\n\n/**\n * Returns true if there is an active observer.\n * @return {boolean}\n */\nexport function isListening() {\n  return !!tracking;\n}\n\n/**\n * Creates a root and executes the passed function that can contain computations.\n * The executed function receives an `unsubscribe` argument which can be called to\n * unsubscribe all inner computations.\n *\n * @param  {Function} fn\n * @return {*}\n */\nexport function root(fn) {\n  const prevTracking = tracking;\n  const rootUpdate = () => {};\n  tracking = rootUpdate;\n  resetUpdate(rootUpdate);\n  const result = fn(() => {\n    _unsubscribe(rootUpdate);\n    tracking = undefined;\n  });\n  tracking = prevTracking;\n  return result;\n}\n\n/**\n * Sample the current value of an observable but don't create a dependency on it.\n *\n * @example\n * computed(() => { if (foo()) bar(sample(bar) + 1); });\n *\n * @param  {Function} fn\n * @return {*}\n */\nexport function sample(fn) {\n  const prevTracking = tracking;\n  tracking = undefined;\n  const value = fn();\n  tracking = prevTracking;\n  return value;\n}\n\n/**\n * Creates a transaction in which an observable can be set multiple times\n * but only trigger a computation once.\n * @param  {Function} fn\n * @return {*}\n */\nexport function transaction(fn) {\n  let prevQueue = queue;\n  queue = [];\n  const result = fn();\n  let q = queue;\n  queue = prevQueue;\n  q.forEach(data => {\n    if (data._pending !== EMPTY_ARR) {\n      const pending = data._pending;\n      data._pending = EMPTY_ARR;\n      data(pending);\n    }\n  });\n  return result;\n}\n\n/**\n * Creates a new observable, returns a function which can be used to get\n * the observable's value by calling the function without any arguments\n * and set the value by passing one argument of any type.\n *\n * @param  {*} value - Initial value.\n * @return {Function}\n */\nfunction observable(value) {\n  function data(nextValue) {\n    if (arguments.length === 0) {\n      if (tracking && !data._observers.has(tracking)) {\n        data._observers.add(tracking);\n        tracking._observables.push(data);\n      }\n      return value;\n    }\n\n    if (queue) {\n      if (data._pending === EMPTY_ARR) {\n        queue.push(data);\n      }\n      data._pending = nextValue;\n      return nextValue;\n    }\n\n    value = nextValue;\n\n    // Clear `tracking` otherwise a computed triggered by a set\n    // in another computed is seen as a child of that other computed.\n    const clearedUpdate = tracking;\n    tracking = undefined;\n\n    // Update can alter data._observers, make a copy before running.\n    data._runObservers = new Set(data._observers);\n    data._runObservers.forEach(observer => (observer._fresh = false));\n    data._runObservers.forEach(observer => {\n      if (!observer._fresh) observer();\n    });\n\n    tracking = clearedUpdate;\n    return value;\n  }\n\n  // Tiny indicator that this is an observable function.\n  data.$o = true;\n  data._observers = new Set();\n  // The 'not set' value must be unique, so `nullish` can be set in a transaction.\n  data._pending = EMPTY_ARR;\n\n  return data;\n}\n\n/**\n * @namespace\n * @borrows observable as o\n */\nexport { observable, observable as o };\n\n/**\n * Creates a new computation which runs when defined and automatically re-runs\n * when any of the used observable's values are set.\n *\n * @param {Function} observer\n * @param {*} value - Seed value.\n * @return {Function} Computation which can be used in other computations.\n */\nfunction computed(observer, value) {\n  observer._update = update;\n\n  // if (tracking == null) {\n  //   console.warn(\"computations created without a root or parent will never be disposed\");\n  // }\n\n  resetUpdate(update);\n  update();\n\n  function update() {\n    const prevTracking = tracking;\n    if (tracking) {\n      tracking._children.push(update);\n    }\n\n    const prevChildren = update._children;\n\n    _unsubscribe(update);\n    update._fresh = true;\n    tracking = update;\n    value = observer(value);\n\n    // If any children computations were removed mark them as fresh.\n    // Check the diff of the children list between pre and post update.\n    prevChildren.forEach(u => {\n      if (update._children.indexOf(u) === -1) {\n        u._fresh = true;\n      }\n    });\n\n    // If any children were marked as fresh remove them from the run lists.\n    const allChildren = getChildrenDeep(update._children);\n    allChildren.forEach(removeFreshChildren);\n\n    tracking = prevTracking;\n    return value;\n  }\n\n  // Tiny indicator that this is an observable function.\n  data.$o = true;\n\n  function data() {\n    if (update._fresh) {\n      update._observables.forEach(o => o());\n    } else {\n      value = update();\n    }\n    return value;\n  }\n\n  return data;\n}\n\nfunction removeFreshChildren(u) {\n  if (u._fresh) {\n    u._observables.forEach(o => {\n      if (o._runObservers) {\n        o._runObservers.delete(u);\n      }\n    });\n  }\n}\n\n/**\n * @namespace\n * @borrows computed as S\n */\nexport { computed, computed as S };\n\n/**\n * Run the given function just before the enclosing computation updates\n * or is disposed.\n * @param  {Function} fn\n * @return {Function}\n */\nexport function cleanup(fn) {\n  if (tracking) {\n    tracking._cleanups.push(fn);\n  }\n  return fn;\n}\n\n/**\n * Subscribe to updates of an observable.\n * @param  {Function} observer\n * @return {Function}\n */\nexport function subscribe(observer) {\n  computed(observer);\n  return () => _unsubscribe(observer._update);\n}\n\n/**\n * Statically declare a computation's dependencies.\n *\n * @param  {Function|Array}   obs\n * @param  {Function} fn - Callback function.\n * @param  {*} [seed] - Seed value.\n * @param  {boolean} [onchanges] - If true the initial run is skipped.\n * @return {Function} Computation which can be used in other computations.\n */\nexport function on(obs, fn, seed, onchanges) {\n  obs = [].concat(obs);\n  return computed((value) => {\n    obs.forEach((o) => o());\n\n    let result = value;\n    if (!onchanges) {\n      result = sample(() => fn(value));\n    }\n\n    onchanges = false;\n    return result;\n  }, seed);\n}\n\n/**\n * Unsubscribe from an observer.\n * @param  {Function} observer\n */\nexport function unsubscribe(observer) {\n  _unsubscribe(observer._update);\n}\n\nfunction _unsubscribe(update) {\n  update._children.forEach(_unsubscribe);\n  update._observables.forEach(o => {\n    o._observers.delete(update);\n    if (o._runObservers) {\n      o._runObservers.delete(update);\n    }\n  });\n  update._cleanups.forEach(c => c());\n  resetUpdate(update);\n}\n\nfunction resetUpdate(update) {\n  // Keep track of which observables trigger updates. Needed for unsubscribe.\n  update._observables = [];\n  update._children = [];\n  update._cleanups = [];\n}\n","export function getChildrenDeep(children) {\n  return children.reduce(\n    (res, curr) => res.concat(curr, getChildrenDeep(curr._children)),\n    []\n  );\n}\n","/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MINI } from './constants.js';\nimport { build, evaluate } from './build.js';\n\nconst CACHES = new Map();\n\nconst regular = function(statics) {\n  let tmp = CACHES.get(this);\n  if (!tmp) {\n    tmp = new Map();\n    CACHES.set(this, tmp);\n  }\n  tmp = evaluate(this, tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp), arguments, []);\n  return tmp.length > 1 ? tmp : tmp[0];\n};\n\nconst custom = function() {\n  const result = (MINI ? build : regular).apply(this, arguments);\n  if (result) {\n    return Array.isArray(result)\n      ? this(result)\n      : typeof result === 'object'\n      ? result\n      : this([result]);\n  }\n};\n\nconst wrapper = function() {\n  const h = custom.bind(this);\n  return (this.wrap || h).apply(h, arguments);\n};\n\nexport default wrapper;\n","import { MINI } from './constants.js';\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst TAG_SET = 1;\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst PROPS_ASSIGN = 3;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\n// Turn a result of a build(...) call into a tree that is more\n// convenient to analyze and transform (e.g. Babel plugins).\n// For example:\n//  treeify(\n//    build'<div href=\"1${a}\" ...${b}><${x} /></div>`,\n//    [X, Y, Z]\n//  )\n// returns:\n//  {\n//    tag: 'div',\n//    props: [ { href: [\"1\", X] },  Y ],\n//    children: [ { tag: Z, props: [], children: [] } ]\n//  }\nexport const treeify = (built, fields) => {\n  const _treeify = built => {\n    let tag = '';\n    let currentProps = null;\n    const props = [];\n    const children = [];\n\n    for (let i = 1; i < built.length; i++) {\n      const field = built[i++];\n      const value = typeof field === 'number' ? fields[field - 1] : field;\n\n      if (built[i] === TAG_SET) {\n        tag = value;\n      }\n      else if (built[i] === PROPS_ASSIGN) {\n        props.push(value);\n        currentProps = null;\n      }\n      else if (built[i] === PROP_SET) {\n        if (!currentProps) {\n          currentProps = Object.create(null);\n          props.push(currentProps);\n        }\n        currentProps[built[++i]] = [value];\n      }\n      else if (built[i] === PROP_APPEND) {\n        currentProps[built[++i]].push(value);\n      }\n      else if (built[i] === CHILD_RECURSE) {\n        children.push(_treeify(value));\n      }\n      else if (built[i] === CHILD_APPEND) {\n        children.push(value);\n      }\n    }\n\n    return { tag, props, children };\n  };\n  const { children } = _treeify(built);\n  return children.length > 1 ? children : children[0];\n};\n\n\nexport const evaluate = (h, built, fields, args) => {\n  let propBody = {};\n  for (let i = 1; i < built.length; i++) {\n    const field = built[i];\n    const value = typeof field === 'number' ? fields[field] : field;\n    const type = built[++i];\n\n    if (type === TAG_SET) {\n      args[0] = value;\n    }\n    else if (type === PROPS_ASSIGN) {\n      args[1] = Object.assign(args[1] || {}, value);\n    }\n    else if (type === PROP_SET) {\n      (args[1] = args[1] || {})[built[++i]] = value;\n    }\n    else if (type === PROP_APPEND) {\n      let key = built[++i];\n      let prev = (args[1] = args[1] || {})[key];\n      let parts = propBody[key];\n\n      if (!parts && (typeof value === 'function' || typeof prev === 'function')) {\n        parts = (prev && [prev]) || [];\n\n        args[1][key] = function() {\n          let prop = '';\n          for (var j = 0; j < parts.length; j++) {\n            prop += typeof parts[j] === 'function' ? parts[j].call(this) : parts[j];\n          }\n          return prop;\n        };\n      }\n\n      if (parts) {\n        parts.push(value);\n      } else {\n        args[1][key] += (value + '');\n      }\n    }\n    else if (type) {\n      // code === CHILD_RECURSE\n      const result = () => h.apply(null, evaluate(h, value, fields, ['', null]));\n\n      // if it's a component we pass the children with closure so the\n      // component is executed before the children of that component.\n      args.push(typeof args[0] === 'function' ? result : result());\n    }\n    else {\n      // code === CHILD_APPEND\n      args.push(value);\n    }\n  }\n\n  return args;\n};\n\nexport const build = function(statics) {\n  const fields = arguments;\n  const h = this;\n\n  let mode = MODE_TEXT;\n  let buffer = '';\n  let quote = '';\n  let current = [0];\n  let char, propName;\n\n  const commit = field => {\n    if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n      if (MINI) {\n        current.push(field ? fields[field] : buffer);\n      }\n      else {\n        current.push(field || buffer, CHILD_APPEND);\n      }\n    }\n    else if (mode === MODE_TAGNAME && (field || buffer)) {\n      if (MINI) {\n        current[1] = field ? fields[field] : buffer;\n      }\n      else {\n        current.push(field || buffer, TAG_SET);\n      }\n      mode = MODE_WHITESPACE;\n    }\n    else if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n      if (MINI) {\n        current[2] = Object.assign(current[2] || {}, fields[field]);\n      }\n      else {\n        current.push(field, PROPS_ASSIGN);\n      }\n    }\n    else if (mode === MODE_WHITESPACE && buffer && !field) {\n      if (MINI) {\n        (current[2] = current[2] || {})[buffer] = true;\n      }\n      else {\n        current.push(true, PROP_SET, buffer);\n      }\n    }\n    else if (mode >= MODE_PROP_SET) {\n      if (MINI) {\n        if (mode === MODE_PROP_SET) {\n          (current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;\n          mode = MODE_PROP_APPEND;\n        }\n        else if (field || buffer) {\n          current[2][propName] += field ? buffer + fields[field] : buffer;\n        }\n      }\n      else {\n        if (buffer || (!field && mode === MODE_PROP_SET)) {\n          current.push(buffer, mode, propName);\n          mode = MODE_PROP_APPEND;\n        }\n        if (field) {\n          current.push(field, mode, propName);\n          mode = MODE_PROP_APPEND;\n        }\n      }\n    }\n\n    buffer = '';\n  };\n\n  for (let i=0; i<statics.length; i++) {\n    if (i) {\n      if (mode === MODE_TEXT) {\n        commit();\n      }\n      commit(i);\n    }\n\n    for (let j=0; j<statics[i].length;j++) {\n      char = statics[i][j];\n\n      if (mode === MODE_TEXT) {\n        if (char === '<') {\n          // commit buffer\n          commit();\n          if (MINI) {\n            current = [current, '', null];\n          }\n          else {\n            current = [current];\n          }\n          mode = MODE_TAGNAME;\n        }\n        else {\n          buffer += char;\n        }\n      }\n      else if (mode === MODE_COMMENT) {\n        // Ignore everything until the last three characters are '-', '-' and '>'\n        if (buffer === '--' && char === '>') {\n          mode = MODE_TEXT;\n          buffer = '';\n        }\n        else {\n          buffer = char + buffer[0];\n        }\n      }\n      else if (quote) {\n        if (char === quote) {\n          quote = '';\n        }\n        else {\n          buffer += char;\n        }\n      }\n      else if (char === '\"' || char === \"'\") {\n        quote = char;\n      }\n      else if (char === '>') {\n        commit();\n        mode = MODE_TEXT;\n      }\n      else if (!mode) {\n        // Ignore everything until the tag ends\n      }\n      else if (char === '=') {\n        mode = MODE_PROP_SET;\n        propName = buffer;\n        buffer = '';\n      }\n      else if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n        commit();\n        if (mode === MODE_TAGNAME) {\n          current = current[0];\n        }\n        mode = current;\n        if (MINI) {\n          (current = current[0]).push(h.apply(null, mode.slice(1)));\n        }\n        else {\n          (current = current[0]).push(mode, CHILD_RECURSE);\n        }\n        mode = MODE_SLASH;\n      }\n      else if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n        // <a disabled>\n        commit();\n        mode = MODE_WHITESPACE;\n      }\n      else {\n        buffer += char;\n      }\n\n      if (mode === MODE_TAGNAME && buffer === '!--') {\n        mode = MODE_COMMENT;\n        current = current[0];\n      }\n    }\n  }\n  commit();\n\n  if (MINI) {\n    return current.length > 2 ? current.slice(1) : current[1];\n  }\n  return current;\n};\n","/* Adapted from DOM Expressions - The MIT License - Ryan Carniato */\nimport { add } from './add.js';\nimport { insert } from './insert.js';\nimport { property } from './property.js';\nimport { api } from './api.js';\nimport { removeNodes } from './remove-nodes.js';\n\napi.insert = insert;\napi.property = property;\napi.add = add;\napi.rm = removeNodes;\n\nexport { context } from './h.js';\nexport { api };\n","/*\n * @param {object} api\n * @param {Function} [api.subscribe] - Function that listens to state changes.\n * @param {Function} [api.cleanup] - Add the given function to the cleanup stack.\n */\nexport const api = {};\n","export const EMPTY_ARR = [];\nexport const GROUPING = '__g';\n","import { castNode } from './cast-node.js';\nimport { frag } from './frag.js';\n\n/**\n * Add a string or node before a reference node or at the end.\n *\n * @param {Node} parent\n * @param {Node|string} value\n * @param {Node} [endMark]\n * @return {Node}\n */\nexport function add(parent, value, endMark) {\n  value = castNode(value);\n\n  const fragOrNode = frag(value) || value;\n\n  // If endMark is `null`, value will be added to the end of the list.\n  parent.insertBefore(value, endMark && endMark.parentNode && endMark);\n\n  return fragOrNode;\n}\n","import { add } from './add.js';\n\nexport function frag(value) {\n  const { childNodes } = value;\n  if (!childNodes || value.nodeType !== 11) return;\n\n  if (childNodes.length < 2) {\n    return childNodes[0];\n  }\n\n  // For a fragment of 2 elements or more add a startMark. This is required\n  // for multiple nested conditional computeds that return fragments.\n  const _startMark = add(value, '', childNodes[0]);\n\n  return {\n    _startMark\n  };\n}\n","import { api } from './api.js';\nimport { EMPTY_ARR } from './constants.js';\n\nexport function castNode(value) {\n  if (typeof value === 'string') {\n    return document.createTextNode(value);\n  }\n  if (!(value instanceof Node)) {\n    // Passing an empty array creates a DocumentFragment.\n    return api.h(EMPTY_ARR, value);\n  }\n  return value;\n}\n","/**\n * Removes nodes, starting from `startNode` (inclusive) to `endMark` (exclusive).\n *\n * @param  {Node} parent\n * @param  {Node} startNode - This is the start node.\n * @param  {Node} endMark - This is the ending marker node.\n */\nexport function removeNodes(parent, startNode, endMark) {\n  while (startNode && startNode !== endMark) {\n    const n = startNode.nextSibling;\n    // Is needed in case the child was pulled out the parent before clearing.\n    if (parent === startNode.parentNode) {\n      parent.removeChild(startNode);\n    }\n    startNode = n;\n  }\n}\n","import { api } from './api.js';\n\nexport function property(el, value, name, isAttr, isCss) {\n  if (value == null) return;\n  if (!name || (name === 'attrs' && (isAttr = true))) {\n    for (name in value) {\n      api.property(el, value[name], name, isAttr, isCss);\n    }\n  } else if (name[0] === 'o' && name[1] === 'n' && !value.$o) {\n    // Functions added as event handlers are not executed\n    // on render unless they have an observable indicator.\n    handleEvent(el, name, value);\n  } else if (typeof value === 'function') {\n    api.subscribe(function setProperty() {\n      api.property(el, value.call({ el, name }), name, isAttr, isCss);\n    });\n  } else if (isCss) {\n    el.style.setProperty(name, value);\n  } else if (\n    isAttr ||\n    name.slice(0, 5) === 'data-' ||\n    name.slice(0, 5) === 'aria-'\n  ) {\n    el.setAttribute(name, value);\n  } else if (name === 'style') {\n    if (typeof value === 'string') {\n      el.style.cssText = value;\n    } else {\n      api.property(el, value, null, isAttr, true);\n    }\n  } else {\n    if (name === 'class') name += 'Name';\n    el[name] = value;\n  }\n}\n\nfunction handleEvent(el, name, value) {\n  name = name.slice(2).toLowerCase();\n\n  if (value) {\n    el.addEventListener(name, eventProxy);\n  } else {\n    el.removeEventListener(name, eventProxy);\n  }\n\n  (el._listeners || (el._listeners = {}))[name] = value;\n}\n\n/**\n * Proxy an event to hooked event handlers.\n * @param {Event} e - The event object from the browser.\n * @return {Function}\n */\nfunction eventProxy(e) {\n  // eslint-disable-next-line\n  return this._listeners[e.type](e);\n}\n","/* Adapted from Hyper DOM Expressions - The MIT License - Ryan Carniato */\nimport { api } from './api.js';\nimport { add } from './add.js';\n\n/**\n * Create a sinuous `h` tag aka hyperscript.\n * @param {object} options\n * @param  {boolean} isSvg\n * @return {Function} `h` tag.\n */\nexport function context(options, isSvg) {\n  for (let i in options) api[i] = options[i];\n\n  function h() {\n    const args = Array.from(arguments);\n    let el;\n\n    function item(arg) {\n      if (arg == null);\n      else if (typeof arg === 'string') {\n        if (el) {\n          add(el, arg);\n        } else {\n          if (isSvg) {\n            el = document.createElementNS('http://www.w3.org/2000/svg', arg);\n          } else {\n            el = document.createElement(arg);\n          }\n        }\n      } else if (Array.isArray(arg)) {\n        // Support Fragments\n        if (!el) el = document.createDocumentFragment();\n        arg.forEach(item);\n      } else if (arg instanceof Node) {\n        if (el) {\n          add(el, arg);\n        } else {\n          // Support updates\n          el = arg;\n        }\n      } else if (typeof arg === 'object') {\n        api.property(el, arg, null, isSvg);\n      } else if (typeof arg === 'function') {\n        if (el) {\n          const endMark = add(el, '');\n          api.insert(el, arg, endMark);\n        } else {\n          // Support Components\n          el = arg.apply(null, args.splice(1));\n        }\n      } else {\n        add(el, '' + arg);\n      }\n    }\n\n    args.forEach(item);\n    return el;\n  }\n\n  return h;\n}\n","import { app } from \"./app\";\n\ndocument.querySelector(\"#root\").append(app());\n","import { api } from './api.js';\nimport { add } from './add.js';\nimport { removeNodes } from './remove-nodes.js';\n\nexport function insert(el, value, endMark, current, startNode) {\n  // This is needed if the el is a DocumentFragment initially.\n  el = (endMark && endMark.parentNode) || el;\n\n  // Save startNode of current. In clear() endMark.previousSibling\n  // is not always accurate if content gets pulled before clearing.\n  startNode = startNode || current instanceof Node && current;\n\n  if (value === current);\n  else if (\n    (!current || typeof current === 'string') &&\n    (typeof value === 'string' || (typeof value === 'number' && (value += '')))\n  ) {\n    // Block optimized for string insertion.\n    if (current == null || !el.firstChild) {\n      if (endMark) {\n        add(el, value, endMark);\n      } else {\n        // textContent is a lot faster than append -> createTextNode.\n        el.textContent = value;\n      }\n    } else {\n      if (endMark) {\n        (endMark.previousSibling || el.lastChild).data = value;\n      } else {\n        el.firstChild.data = value;\n      }\n    }\n    current = value;\n  } else if (typeof value === 'function') {\n    api.subscribe(function insertContent() {\n      current = api.insert(el, value.call({ el, endMark }), endMark, current, startNode);\n    });\n  } else {\n    // Block for nodes, fragments, Arrays, non-stringables and node -> stringable.\n    if (endMark) {\n      // `current` can't be `0`, it's coerced to a string in insert.\n      if (current) {\n        if (!startNode) {\n          // Support fragments\n          startNode = (current._startMark && current._startMark.nextSibling)\n            || endMark.previousSibling;\n        }\n        removeNodes(el, startNode, endMark);\n      }\n    } else {\n      el.textContent = '';\n    }\n    current = null;\n\n    if (value && value !== true) {\n      current = add(el, value, endMark);\n    }\n  }\n\n  return current;\n}\n","import { scopeStyles } from \"./scopeStyles\";\nimport { api, html as sinuousHtml, svg as sinuousSvg } from \"sinuous\";\nimport { root, cleanup } from \"sinuous/observable\";\nimport { isFunction } from \"./utils\";\n\nlet scopeName;\nlet scopeNameCounts = {};\nlet styleElementIds = new Set([]);\n\nconst pipe = (f, g) => (...args) => g(...f(...args));\n\nlet originalH = api.h;\n// Wrap the native apis\napi.h = pipe(scopeElementClasses, api.h);\napi.hs = pipe(\n  // Assume there will be no style elements nested inside svg\n  injectScopeName,\n  api.hs\n);\n\nlet head = document.querySelector(\"head\");\n\nfunction addStyleElement(styleElement) {\n  head.append(styleElement);\n}\nfunction removeStyleByClassName(className) {\n  for (let element of head.querySelectorAll(\".\" + className)) {\n    if (element.nodeName === \"STYLE\") {\n      /*\n        Remove the style element id from the styleElementIds so that if another\n        corresponding component is added, the style element will again\n        be appended to the dom.\n      */\n      styleElementIds.delete(element.id);\n      // Remove the style element from the dom.\n      element.remove();\n    }\n  }\n}\n\n/* \n    If an appropriate style element, scope all selectors and inject the style element\n    directly onto the body of the page. Otherwise, inject the scopeName. Return the\n    `args` to be passed into `api.h`.\n  */\nfunction scopeElementClasses(...args) {\n  if (args[0] === \"style\" && args[1] && (args[1].local || args[1].global)) {\n    let props = args[1];\n    let local = props.local;\n    let className = props.class;\n    props.class = scopeName + \" \" + (props.class || \"\");\n    let modifiedScopeName =\n      (local ? scopeName + \"-local\" : scopeName + \"-global\") +\n      (className ? \"-\" + className : \"\");\n    if (\n      styleElementIds.has(modifiedScopeName) ||\n      head.querySelector(\"#\" + modifiedScopeName)\n    ) {\n      return [];\n    }\n    styleElementIds.add(modifiedScopeName);\n\n    /* \n      Create a style element and append it to the document head rather than\n      passing it through to be created by api.h in the normal fashion.\n    */\n    props.id = modifiedScopeName;\n    let rest = local ? scopeStyles(args.slice(2), scopeName) : args.slice(2);\n    let styleElement = root(() => originalH(args[0], props, ...rest));\n    addStyleElement(styleElement);\n\n    return [];\n  } else {\n    return injectScopeName(...args);\n  }\n}\n\n/*\n  Wraps the callback in a newScopeName.\n*/\nfunction wrapInScope(newScopeName, callback) {\n  // Keep a reference to the outer scope.\n  let outerScopeName = scopeName;\n  // Create new scope.\n  scopeName = newScopeName;\n  let result = callback();\n  // Reset the scope to the outer scope.\n  scopeName = outerScopeName;\n  return result;\n}\n\n/* \n  Inject the scopeName into every element as an additional className.\n  Ensure that passed children are scoped lexically rather than dynamically.\n  Return the `args` to be passed into `api.h` or `api.hs`.  \n*/\nfunction injectScopeName(...args) {\n  /*\n    If the node is a component wrap its children in the scope\n    of where they apppear in the markup, not the scope of this\n    component. The `$s` annotation on this component contains\n    that `scopeName`.\n\n    This makes the scope lexical rather than dynamic.\n  */\n  if (isFunction(args[0])) {\n    let staticScopeName = args[0].$s;\n    for (let i = 2; i < args.length; i++) {\n      if (isFunction(args[i])) {\n        let temp = args[i];\n        args[i] = () => wrapInScope(staticScopeName, temp);\n      }\n    }\n  }\n\n  let props = args[1] || {};\n  let baseClass = props.class || \"\";\n  /*\n    Set the current value of `scopeName` to a variable so that the changing \n    `scopeName` variable (in the case that the `baseClass` is a function) \n    is not captured by the closure.\n  */\n  let staticScopeName = scopeName || \"\";\n  props.class = isFunction(baseClass)\n    ? () => baseClass() + \" \" + staticScopeName\n    : baseClass + \" \" + staticScopeName;\n  args[1] = props;\n  return args;\n}\n\n/*\n  Wraps Sinuous `html` or `svg`. The wrapped functions handle scoping.\n\n  The usage of that wrapped function is as follows:\n    1. html('new-scope-name')`...` - sets a new scope ('new-scope-name')\n    2. html()`...` - propagates the outer scope (useful in the case of conditionals)\n    3. html`...` - blocks the outer scope\n*/\nfunction wrapApiFunction(fn) {\n  return (...args) => {\n    if (Array.isArray(args[0])) {\n      // html`...` - block outer scope\n      return wrapInScope(\"\", () => fn(...args));\n    } else {\n      // html(scopeName)`...` - set a new scope\n      // html()`...` - propagate outer scope\n      return (...templateArgs) => {\n        return wrapInScope(args.length ? args[0] : scopeName, () => {\n          /*\n            Annotate each child function with `$s` so that any\n            child components that render passed children can give\n            their children this `scopeName` rather than the `scopeName`\n            of that component.\n\n            This makes the scope lexical rather than dynamic.\n          */\n          for (let item of templateArgs) {\n            if (isFunction(item)) {\n              item.$s = scopeName;\n            }\n          }\n\n          // Track how many elements using this particular scopeName\n          // are present on the dom.\n          let staticScopeName = scopeName;\n          if (!scopeNameCounts[staticScopeName]) {\n            scopeNameCounts[staticScopeName] = 1;\n          } else scopeNameCounts[staticScopeName]++;\n          // Remove the corresponding style elements when the\n          // number of elements using this scopeName goes to 0.\n          cleanup(() => {\n            if (--scopeNameCounts[staticScopeName] < 1) {\n              delete scopeNameCounts[staticScopeName];\n              removeStyleByClassName(staticScopeName);\n            }\n          });\n          return fn(...templateArgs);\n        });\n      };\n    }\n  };\n}\n\n// To be used in place of Sinuous `html` and `svg`\nconst html = wrapApiFunction(sinuousHtml);\nconst svg = wrapApiFunction(sinuousSvg);\n\nexport { html, svg };\n","import { html } from \"sinuous-style\";\n\nexport const card = ({ title }, ...children) => {\n  return html(\"card\")`\n    <section>\n      <h2>${title}</h2>\n      ${children}\n    </section>\n\n    <style local>\n      section {\n        background: #f3f3f3;\n        padding: 20px;\n        border-radius: 10px;\n        margin-top: 20px;\n        margin-bottom: 20px;\n        text-align: center;\n      }\n\n      h2 {\n        margin-top: 0px;\n        text-align: center;\n      }\n    </style>\n  `;\n};\n","import { html } from \"sinuous-style\";\nimport { o } from \"sinuous\";\nimport { card } from \"../components/card\";\n\nexport const counter = () => {\n  let count = o(0);\n\n  return html(\"counter\")`\n    <${card} title=\"Counter\">\n      ${count}\n      <button onclick=${() => count(count() + 1)}>+</button>\n    <//>\n\n    <style local>\n      button {\n        margin-left: 15px;\n      }\n    </style>\n  `;\n};\n","import { html } from \"sinuous-style\";\nimport { o } from \"sinuous\";\nimport { card } from \"../components/card\";\n\nfunction trunc(n) {\n  return Number(n.toFixed(2));\n}\n\nfunction remove0(n) {\n  if (/^0\\d+$/.test(n)) return n.slice(1);\n  if (/^-0\\d+$/.test(n)) return \"-\" + n.slice(2);\n  return n;\n}\n\nfunction getC(f) {\n  return trunc((5 / 9) * (f - 32)) || -17.78; // 0 F\n}\nfunction getF(c) {\n  return trunc((9 / 5) * c + 32) || 32; // 0 C\n}\nlet r = /^-?\\d*.?\\d*$/;\nfunction isValid(temp) {\n  if (/^-?\\d*$/.test(temp)) return true;\n  if (/^-?\\d+[.]?\\d*$/.test(temp)) return true;\n  return false;\n}\n\nexport const temperatureConverter = () => {\n  let c = o(0);\n  let f = o(32);\n\n  const updateFromC = (e) => update(e, c, f, getF);\n  const updateFromF = (e) => update(e, f, c, getC);\n\n  const update = (e, from, to, get) => {\n    let value = e.target.value; //|| \"0\";\n    if (!isValid(value)) return;\n    value = remove0(value);\n    from(value);\n    to(get(value));\n  };\n\n  return html(\"temperature-converter\")`\n    <${card} title=\"Temperature Converter\">\n      <span>\n        <input value=${c} oninput=${updateFromC} />\n        Celsius\n      </span>\n      =\n      <span>\n        <input value=${f} oninput=${updateFromF} />\n        Fahrenheit\n      </span>\n    <//>\n\n    <style local>\n      span {\n        display: inline-block;\n        padding-left: 10px;\n        padding-right: 10px;\n      }\n    </style>\n  `;\n};\n","import { html } from \"sinuous-style\";\nimport { S, o } from \"sinuous/observable\";\nimport { card } from \"../components/card\";\n\nlet flightMap = {\n  1: \"one-way flight\",\n  2: \"return flight\",\n};\n\nfunction tryAsDate(dateString) {\n  let dateArr = dateString.split(\".\").reverse();\n  if (dateArr[1].length !== 2 || dateArr[2].length !== 2) {\n    return false;\n  }\n  let date = new Date(dateArr.join(\"-\"));\n  return date.valueOf() || false;\n}\n\nfunction formatAsString(date) {\n  return date.toISOString().slice(0, 10).split(\"-\").reverse().join(\".\");\n}\n\nexport const flightBooker = () => {\n  let flightType = o(1);\n  let startDate = o(formatAsString(new Date()));\n  let returnDate = o(formatAsString(new Date()));\n\n  let error1 = S(() => !tryAsDate(startDate()));\n  let error2 = S(() => !tryAsDate(returnDate()));\n  let error3 = S(() => tryAsDate(returnDate()) < tryAsDate(startDate()));\n\n  let isBookButtonDisabled = S(() => error1() || error2() || error3());\n  let isOneWay = S(() => flightType() === 1);\n  let startDateClass = S(() => (error1() ? \"error\" : \"\"));\n  let returnDateClass = S(() => (error2() ? \"error\" : \"\"));\n\n  function book() {\n    let timeStrings = {\n      1: \" for \" + startDate(),\n      2: \" from \" + startDate() + \" to \" + returnDate(),\n    };\n    alert(\n      \"You have booked a \" + flightMap[flightType()] + timeStrings[flightType()]\n    );\n  }\n\n  return html(\"flight-booker\")`\n    <${card} title=\"Flight Booker\">\n      <div>\n        <select value=${flightType} onchange=${(e) =>\n    flightType(e.target.value)}>\n          <option value=\"{1}\">${flightMap[1]}</option>\n          <option value=\"{2}\">${flightMap[2]}</option>\n        </select>\n        <input\n          value=${startDate}\n          class=${startDateClass}\n          oninput=${(e) => startDate(e.target.value)}\n        />\n        <input\n          value=${returnDate}\n          class=${returnDateClass}\n          oninput=${(e) => returnDate(e.target.value)}\n          disabled=${isOneWay}\n        />\n        <button onclick=${book} disabled=${isBookButtonDisabled}>\n          Book\n        </button>\n      </div>\n    <//>\n\n    <style local>\n      div {\n        max-width: 400px;\n        margin: auto;\n      }\n\n      div > * {\n        width: 100%;\n        display: block;\n      }\n\n      :disabled {\n        background: #eee;\n      }\n\n      .error {\n        background: #dd9999;\n      }\n    </style>\n  `;\n};\n","import { html } from \"sinuous-style\";\nimport { S, o } from \"sinuous/observable\";\nimport { card } from \"../components/card\";\n\nexport const timer = () => {\n  const MAX = 30000;\n\n  let duration = o(5000);\n  let durationFormatted = S(() => (duration() / 1000).toFixed(1));\n  let start = o();\n  let time = o();\n  let progress = S(() => (time() - start()) / duration());\n  let interval;\n\n  function createInterval() {\n    return setInterval(() => {\n      time(new Date().valueOf());\n    }, 10);\n  }\n  function startTimer() {\n    clearInterval(interval);\n    start(new Date().valueOf());\n    time(start());\n    interval = createInterval();\n  }\n\n  startTimer();\n\n  return html(\"timer\")`\n    <${card} title=\"Timer\">\n      <div class=\"wrapper\">\n        Elapsed Time:\n        <progress value=${progress} />\n        <div class=\"duration\">${durationFormatted}s</div>\n        Duration:\n        <input\n          type=\"range\"\n          min=${0}\n          max=${MAX}\n          value=${duration}\n          oninput=${(e) => duration(e.target.value)}\n        />\n        <button onclick=${startTimer}>Reset Timer</button>\n      </div>\n    <//>\n\n    <style local>\n      .wrapper {\n        max-width: 400px;\n        text-align: left;\n        margin: auto;\n        display: grid;\n        grid-template-columns: auto auto;\n        grid-template-rows: auto;\n        grid-gap: 10px 10px;\n        grid-auto-flow: row;\n      }\n\n      input {\n        padding: 0;\n        justify-self: stretch;\n        align-self: center;\n      }\n\n      button {\n        grid-column: 1/3;\n        grid-row: auto;\n      }\n\n      .duration {\n        grid-column: 2;\n      }\n    </style>\n  `;\n};\n","import { html } from \"sinuous-style\";\nimport { S, subscribe, o } from \"sinuous/observable\";\nimport { card } from \"../components/card\";\n\nexport const crud = () => {\n  let prefix = o(\"\");\n  let entries = o([\n    o([\"Paul\", \"Atreides\"]),\n    o([\"Gurney\", \"Halleck\"]),\n    o([\"Duncan\", \"Idaho\"]),\n  ]);\n  let filteredEntries = S(() =>\n    // get filtered entries in which entry[1] startsWith prefix\n    // get array of [entry[0], entry[1], index]\n    entries()\n      .map((entry, i) => [entry()[0], entry()[1], i])\n      .filter((entry) =>\n        entry[1].toLowerCase().startsWith(prefix().toLowerCase())\n      )\n  );\n  let name = o(\"\");\n  let surname = o(\"\");\n  let selected = o(-1);\n  subscribe(() => {\n    prefix();\n    selected(-1);\n  });\n\n  function createHandler() {\n    entries(entries().concat(o([name(), surname()])));\n  }\n  function updateHandler() {\n    // if selected > -1 then update entries[selected]\n    selected() > -1 && entries()[selected()]([name(), surname()]);\n  }\n  function deleteHandler() {\n    // if selected > -1 then delete entries[selected]\n    selected() > -1 && entries(entries().filter((entry, i) => i != selected()));\n  }\n\n  return html(\"crud\")`\n    <${card} title=\"CRUD\">\n      <div class=\"wrapper\">\n        Filter prefix:\n        <input value=${prefix} oninput=${(e) => prefix(e.target.value)} />\n        <select\n          value=${selected}\n          oninput=${(e) => selected(e.target.value)}\n          size=\"4\"\n        >\n          ${() =>\n            filteredEntries().map(\n              (entry) => html`\n                <option value=${entry[2]}>${entry[1]}, ${entry[0]}</option>\n              `\n            )}\n        </select>\n        <div>\n          Name:\n          <input value=${name} oninput=${(e) => name(e.target.value)} />\n          Surname:\n          <input value=${surname} oninput=${(e) => surname(e.target.value)} />\n        </div>\n        <div class=\"buttons\">\n          <button onclick=${createHandler}>Create</button>\n          <button onclick=${updateHandler}>Update</button>\n          <button onclick=${deleteHandler}>Delete</button>\n        </div>\n      </div>\n    <//>\n\n    <style local>   \n      .wrapper {\n        max-width: 400px;\n        text-align: left;\n        margin: auto;\n        display: grid;\n        grid-template-columns: 150px auto;\n        grid-template-rows: auto;\n        grid-gap: 10px 10px;\n        grid-auto-flow: row;\n      }\n\n      .buttons {\n        grid-column: 1/3;\n        display: flex;\n        justify-content: space-evenly;\n      }\n\n      button {\n        flex: 1 1 0%;\n      }\n\n      input {\n        width: 100%;\n      }\n    </style>\n  `;\n};\n","import {html, svg} from 'sinuous-style'\nimport { subscribe, sample, o } from \"sinuous/observable\";\nimport { card } from \"../components/card\";\n\nexport const circleDrawer = () => {\n  const BASE_RADIUS = 30;\n\n  let step = o(0);\n  let snapshots = o([o([])]);\n  let radius = o(BASE_RADIUS);\n  let resizing = o(false);\n  let present = o([]);\n  subscribe(() => present(snapshots()[step()]()));\n  subscribe(() => {\n    if (resizing()) {\n      let resizingIndex = sample(present).findIndex(\n        circle => circle.x === resizing().x && circle.y === resizing().y\n      );\n      let newPresent = sample(present).slice();\n      newPresent[resizingIndex] = {\n        ...sample(present)[resizingIndex],\n        r: Number(radius())\n      };\n      present(newPresent);\n    }\n  });\n\n  function handleRightClick(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    let circle = e.target;\n    resizing({\n      x: circle.cx.baseVal.value,\n      y: circle.cy.baseVal.value,\n      r: circle.r.baseVal.value\n    });\n    radius(resizing().r);\n  }\n\n  function addCircle(e) {\n    let x = e.layerX;\n    let y = e.layerY;\n    let newSnapshot = present().slice();\n    newSnapshot.push({ x, y, r: BASE_RADIUS });\n    addSnapshot(o(newSnapshot));\n  }\n\n  function addSnapshot(newSnapshot) {\n    let newSnapshots = snapshots().slice(0, step() + 1);\n    newSnapshots.push(newSnapshot);\n    snapshots(newSnapshots);\n    step(step() + 1);\n  }\n\n  function undo() {\n    step(Math.max(step() - 1, 0));\n  }\n\n  function redo() {\n    step(Math.min(step() + 1, snapshots().length - 1));\n  }\n\n  function endResize() {\n    if (radius() !== resizing().r) {\n      resizing(false);\n      radius(BASE_RADIUS);\n      addSnapshot(o(present().slice()));\n    }\n    resizing(false);\n  }\n\n  const overlay = () => html('circle-drawer')`\n    <div class=\"overlay\" onclick=${endResize}></div>\n    <div class=\"resizer\">\n      <p>\n        Adjust radius of circle at (${() => resizing().x},\n        ${() => resizing().y})\n      </p>\n      <p>${radius}</p>\n      <input\n        type=\"range\"\n        min=${0}\n        max=${100}\n        value=${radius}\n        oninput=${e => radius(e.target.value)}\n      />\n    </div>\n  `;\n\n  const circleSVG = ({ circle, handleRightClick }) => {\n    return svg()`\n      <circle\n        cx=${circle.x}\n        cy=${circle.y}\n        r=${circle.r}\n        fill=\"white\"\n        stroke=\"black\"\n        onclick=${e => {\n          e.preventDefault();\n          e.stopPropagation();\n        }}\n        oncontextmenu=${handleRightClick}\n      />\n    `;\n  };\n\n  const view = html('circle-drawer')`\n    <${card} title=\"Circle Drawer\">\n      <div class=\"wrapper\">\n        <div class=\"buttons\">\n          <button disabled=${() => !step()} onclick=${undo}>Undo</button>\n          <button\n            disabled=${() => step() === snapshots().length - 1}\n            onclick=${redo}\n          >\n            Redo\n          </button>\n        </div>\n        <div class=\"canvas\">\n          ${() => svg()`\n            <svg onclick=${addCircle}>\n              ${() =>\n                present().map(\n                  (cir) =>\n                    html()`\n                      <${circleSVG}\n                        circle=${cir}\n                        handleRightClick=${handleRightClick}\n                      />\n                    `\n                )}\n            </svg>\n          `}\n        </div>\n        ${() => resizing() && overlay}\n      </div>\n    <//>\n\n    <style local>\n      .wrapper {\n        max-width: 400px;\n        text-align: left;\n        margin: auto;\n        position: relative;\n      }\n\n      .canvas {\n        width: 100%;\n        height: 400px;\n        position: relative;\n      }\n\n      .overlay {\n        position: fixed;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        background: transparent;\n      }\n\n      .resizer {\n        background: rgba(200, 200, 200, 0.5);\n        position: absolute;\n        top: 50%;\n        left: 20px;\n        right: 20px;\n        transform: translateY(-50%);\n        text-align: center;\n      }\n\n      .buttons {\n        margin: auto;\n        width: max-content;\n      }\n\n      svg {\n        background: white;\n        width: 100%;\n        height: 100%;\n      }\n\n      circle:hover {\n        fill: #eee;\n      }\n    </style>\n  `;\n\n  return view;\n};\n","export let sampleData = {\n  A0: 'Data',\n  A1: '20',\n  A2: '15',\n  A3: 'text',\n  B1: '79',\n  B2: '3.9',\n  A5: 'Formula',\n  B5: 'Output',\n  A6: '\"=sum(D1:D5)\"',\n  B6: '=sum(D1:D5)',\n  A7: '\"=sub(A1:B2)\"',\n  B7: '=sub(A1:B2)',\n  A8: '\"=mul(D1:D5)\"',\n  B8: '=mul(D1:D5)',\n  A9: '\"=div(A1:B2)\"',\n  B9: '=div(A1:B2)',\n  A10: '\"=mod(A1:B2)\"',\n  B10: '=mod(A1:B2)',\n  C0: 'Formula',\n  D0: 'Output',\n  C1: '\"=sum(A1,A2)\"',\n  D1: '=sum(A1,A2)',\n  C2: '\"=sub(D1,A1)\"',\n  D2: '=sub(D1,A1)',\n  C3: '\"=mul(D2,A2)\"',\n  D3: '=mul(D2,A2)',\n  C4: '\"=div(D3,A1)\"',\n  D4: '=div(D3,A1)',\n  C5: '\"=mod(A1,A2)\"',\n  D5: '=mod(A1,A2)',\n  C7: '\"=sum(A1,A3)\"',\n  D7: '=sum(A1,A3)',\n  C8: '\"=sum(A1,A4)\"',\n  D8: '=sum(A1,A4)',\n  C9: '\"=sumA1,A4)\"',\n  D9: '=sumA1,A4)',\n  C10: '\"=sm(A1,A4)\"',\n  D10: '=sm(A1,A4)',\n  C11: '\"=sum(A1,307)\"',\n  D11: '=sum(A1,307)',\n  C12: '\"=sum(159,4)\"',\n  D12: '=sum(159,4)',\n  C14: '\"=A1\"',\n  D14: '=A1',\n  C15: '\"=A3\"',\n  D15: '=A3'\n}\n","import {subscribe} from 'sinuous/observable'\n\nexport class Parser {\n  constructor(store, columns, rows) {\n    this.cells = {}\n    this.store = store\n    this.columns = columns\n    this.rows = rows\n    this.operations = {\n      sum: (a, b) => a + b,\n      sub: (a, b) => a - b,\n      mul: (a, b) => a * b,\n      div: (a, b) => a / b,\n      mod: (a, b) => a % b,\n      exp: (a, b) => a ** b\n    }\n\n    subscribe(() => this.cells = this.store())\n  }\n\n  cartesianProduct(letters, numbers) {\n    var result = []\n    letters.forEach(letter => {\n      numbers.forEach(number => {\n        result.push(letter + number)\n      })\n    })\n    return result\n  }\n\n  findArrRange(arr, start, end) {\n    let startI = arr.indexOf(start)\n    let endI = arr.indexOf(end)\n    if (startI == -1 || endI == -1 || startI > endI) return []\n    return arr.slice(startI, endI + 1)\n  }\n\n  getRange(rangeStart, rangeEnd) {\n    rangeStart = this.splitOperand(rangeStart)\n    rangeEnd = this.splitOperand(rangeEnd)\n    let letters = this.findArrRange(this.columns, rangeStart[0], rangeEnd[0])\n    let numbers = this.findArrRange(this.rows, rangeStart[1], rangeEnd[1])\n    return this.cartesianProduct(letters, numbers)\n  }\n\n  splitOperand(operand) {\n    return [operand.match(/[a-zA-Z]+/)[0], Number(operand.match(/\\d+/)[0])]\n  }\n\n  rangeOperation(op, rangeStart, rangeEnd) {\n    if (!(this.isWellFormed(rangeStart) && this.isWellFormed(rangeEnd)))\n      return this.originalString\n\n    let range = this.getRange(rangeStart, rangeEnd)\n\n    return range\n      .map(address => Number(this.parse(this.cells[address]())))\n      .reduce(this.operations[op])\n  }\n\n  singleOperation(op, operand1, operand2) {\n    let first = this.parseOperand(operand1)\n    let second = this.parseOperand(operand2)\n\n    if (first === null || second === null) return this.originalString\n\n    return this.operations[op](first, second).toString()\n  }\n\n  isWellFormed(operand) {\n    return /[a-zA-Z]+\\d+/.test(operand)\n  }\n\n  parseOperand(operand) {\n    if (!isNaN(Number(operand))) return Number(operand)\n    if (operand in this.cells) return Number(this.parse(this.cells[operand]()))\n    if (this.isWellFormed(operand)) return 0\n\n    return null\n  }\n\n  parseOperation(op, formula) {\n    if (!(formula.startsWith('(') && formula.endsWith(')')))\n      return this.originalString\n\n    formula = formula.slice(1, formula.length - 1)\n\n    let operationType\n    let formulaArr\n    if (formula.includes(',')) {\n      operationType = 'single'\n      formulaArr = formula.split(',')\n    } else if (formula.includes(':')) {\n      operationType = 'range'\n      formulaArr = formula.split(':')\n    }\n\n    if (formulaArr.length !== 2) return this.originalString\n\n    if (operationType === 'single')\n      return this.singleOperation(op, formulaArr[0], formulaArr[1])\n\n    if (operationType === 'range')\n      return this.rangeOperation(op, formulaArr[0], formulaArr[1])\n\n    return this.originalString\n  }\n\n  parse(str) {\n    this.originalString = str\n    if (typeof str !== 'string') return ''\n    if (!str.startsWith('=')) return str\n\n    let formula = str.slice(1)\n    if (formula.slice(0, 3).toLowerCase() in this.operations) {\n      return this.parseOperation(\n        formula.slice(0, 3).toLowerCase(),\n        formula.slice(3).toUpperCase()\n      )\n    } else {\n      return this.cells[formula] || str\n    }\n  }\n}\n","import { html } from \"sinuous-style\";\nimport { sample, o, subscribe } from \"sinuous/observable\";\nimport { card } from \"../../components/card\";\nimport { sampleData } from \"./sampleData.js\";\nimport { Parser } from \"./parse.js\";\n\nconst LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nfunction range(n) {\n  return [...Array(n).keys()];\n}\nfunction letterRange(n) {\n  return range(n).map(getNumberAsLetters);\n}\nfunction getBase26(n) {\n  let result = [];\n  while (n > 25) {\n    let remainder = n % 26;\n    result.push(remainder);\n    n = Math.floor(n / 26) - 1;\n  }\n  result.push(n);\n  return result.reverse();\n}\nfunction getNumberAsLetters(n) {\n  let arr = getBase26(n);\n  return arr.map((num) => LETTERS[num]).join(\"\");\n}\nfunction findAdjacent(arr, value, direction) {\n  let index = arr.indexOf(value);\n  if (index === -1) return null;\n  if (direction === \"before\")\n    return arr[index - 1] === undefined ? null : arr[index - 1];\n  if (direction === \"after\") return arr[index + 1] || null;\n  return null;\n}\n\nexport const cells = (props) => {\n  let shape = (props && props.shape) || [100, 100];\n\n  Object.keys(sampleData).forEach((key) => {\n    // Make each entry an observable\n    sampleData[key] = o(sampleData[key]);\n  });\n  const data = o(sampleData);\n\n  const rows = range(shape[1]);\n  const columns = letterRange(shape[0]);\n  const p = new Parser(data, columns, rows);\n\n  let focused = o(undefined);\n  let tBody; // Used as a ref\n\n  function createNewCell(key) {\n    let dataRef = sample(data);\n    if (!dataRef[key]) {\n      dataRef[key] = o(\"\");\n      data(dataRef);\n    }\n  }\n\n  function handleFocus(key) {\n    if (focused() !== key) {\n      createNewCell(key);\n      focused(key);\n      let target = tBody.querySelector(\"#input-\" + key);\n      if (target) {\n        target.focus();\n        target.setSelectionRange(0, 9999);\n      }\n    }\n  }\n\n  function handleBlur(key) {\n    if (focused() === key) focused(undefined);\n  }\n\n  function handleInput(e, key) {\n    sample(data)[key](e.target.value);\n  }\n\n  function handleKeydown(e, column, row) {\n    // Navigate across the spreadsheet with arrow keys (and alt/option key)\n    let selector;\n    if (e.key === \"ArrowUp\") {\n      let newRow = findAdjacent(rows, row, \"before\");\n      selector = newRow !== null ? column + newRow : null;\n    }\n    if (e.key === \"ArrowDown\" || e.key === \"Enter\") {\n      let newRow = findAdjacent(rows, row, \"after\");\n      selector = newRow !== null ? column + newRow : null;\n    }\n    if (e.key === \"ArrowLeft\" && e.altKey) {\n      let newColumn = findAdjacent(columns, column, \"before\");\n      selector = newColumn !== null ? newColumn + row : null;\n    }\n    if (e.key === \"ArrowRight\" && e.altKey) {\n      let newColumn = findAdjacent(columns, column, \"after\");\n      selector = newColumn !== null ? newColumn + row : null;\n    }\n\n    if (selector) {\n      e.preventDefault();\n      handleFocus(selector);\n    }\n  }\n\n  function clear() {\n    data({});\n  }\n\n  const cellView = ({ j, i }) => {\n    let key = j + i;\n    let hasFocus = o(false);\n\n    subscribe(() => {\n      if (focused() === key && !sample(hasFocus)) {\n        hasFocus(true);\n      } else if (focused() !== key && sample(hasFocus)) {\n        hasFocus(false);\n      }\n    });\n\n    return html()` ${() =>\n      hasFocus()\n        ? html(\"cells\")`\n            <input\n              id=${\"input-\" + key}\n              autofocus\n              value=${() => (key in data() ? data()[key]() : \"\")}\n              onfocus=${() => handleFocus(key)}\n              onblur=${() => handleBlur(key)}\n              onkeydown=${(e) => handleKeydown(e, j, i)}\n              oninput=${(e) => handleInput(e, key)}\n            />\n          `\n        : html(\"cells\")`\n            <div>${() => (key in data() ? p.parse(data()[key]()) : \"\")}</div>\n          `}`;\n  };\n\n  const view = html(\"cells\")`\n    <${card} title=\"Cells\">\n      <div class=\"wrapper\">\n        <table>\n          <thead>\n            <tr>\n              <td class=\"row-key\"></td>\n              ${() =>\n                columns.map(\n                  (column) => html()` <td class=\"column-key\">${column}</td> `\n                )}\n            </tr>\n          </thead>\n          <tbody>\n            ${() =>\n              rows.map(\n                (i) => html()`\n                  <tr id=${\"row-\" + i}>\n                    <td class=\"row-key\">${i}</td>\n                    ${() =>\n                      columns.map(\n                        (j) => html()`\n                          <td id=${j + i} onclick=${() => handleFocus(j + i)}>\n                            <${cellView} j=${j} i=${i} />\n                          </td>\n                        `\n                      )}\n                  </tr>\n                `\n              )}\n          </tbody>\n        </table>\n      </div>\n      <button onclick=${clear}>Clear</button>\n    <//>\n\n    <style local>\n    .wrapper {\n      margin: auto;\n      overflow: scroll;\n      max-width: 600px;\n      max-height: 600px;\n      border: solid 1px #ddd;\n    }\n    \n    table {\n      table-layout: fixed;\n      border-collapse: collapse;\n      border: solid 1px #ddd;\n      background: white;\n    }\n    \n    td {\n      height: 30px;\n      border: solid 1px #ddd;\n      overflow: hidden;\n      text-align: right;\n    }\n    \n    td > div {\n      width: 100%;\n      max-width: 120px;\n      overflow: hidden;\n      white-space: nowrap;\n    }\n    \n    input {\n      width: 100%;\n      height: 100%;\n      margin: 0;\n      padding: 0;\n      text-align: right;\n      border: none;\n      outline: none;\n    }\n    \n    input:focus {\n      text-align: left;\n    }\n    \n    .row-key {\n      width: min-content;\n      padding-left: 15px;\n      padding-right: 15px;\n    }\n    \n    .column-key {\n      min-width: 120px;\n      text-align: center;\n    }\n    </style>\n  `;\n\n  tBody = view.querySelector(\"tbody\"); // Assign ref to domNode\n\n  return view;\n};\n","import { html } from \"sinuous-style\";\n\nimport { counter } from \"./tasks/counter\";\nimport { temperatureConverter } from \"./tasks/temperatureConverter\";\nimport { flightBooker } from \"./tasks/flightBooker\";\nimport { timer } from \"./tasks/timer\";\nimport { crud } from \"./tasks/crud\";\nimport { circleDrawer } from \"./tasks/circleDrawer\";\nimport { cells } from \"./tasks/cells/cells\";\n\nexport const app = () => {\n  return html(\"app\")`\n    <main>\n      <a href=\"../../index.html\">Home</a>\n\n      <${counter} />\n      <${temperatureConverter} />\n      <${flightBooker} />\n      <${timer} />\n      <${crud} />\n      <${circleDrawer} />\n      <${cells} />\n    </main>\n\n    <style local>\n      main {\n        max-width: 800px;\n        margin: auto;\n      }\n    </style>\n  `;\n};\n","import { app } from \"./app\";\n\ndocument.querySelector(\"#root\").append(app());\n"]}